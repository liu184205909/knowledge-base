# feature-dev 智能体开发 SOP

**基于 feature-dev 的"谋定而后动"理念** | v2.1 (优化版)

---

## 💡 Claude Code之父Boris Cherny的核心经验

> **基于Claude Code创建者30天259个PR的实战经验**

### ⭐⭐⭐ 最重要：验证反馈循环

> **给Claude验证工作的方式，质量会提升2-3倍**

每个功能开发后必须：
1. 让Claude自己测试
2. 发现问题
3. 自己修复
4. 再测试
5. 直到通过

**验证方式**：
- 运行测试套件
- 在浏览器/模拟器中测试
- 运行bash命令验证

### ⭐ Plan模式优先

> **大多数会话从Plan模式开始**（按两次shift+tab）

- 先用Plan模式来回讨论直到满意计划
- 然后切换到自动接受编辑模式
- **一个好的计划真的很重要！**

### 成本意识

- ✅ 高价值任务：需求分析、架构设计、复杂功能
- ❌ 廉价操作：commit、push、简单文件操作
- 💡 原则：把珍贵的AI能力用在刀刃上

---

## 🎯 7 阶段智能体工作流

```
反向面试 → 探索 → 设计 → 执行 → 测试 → 审查 → 发布
```

## ✅ 完成定义（DoD）：什么时候算“真的做完了”？

> 强烈建议：每次合并/发布前都对照一次，避免“功能看起来能用，但线上会出事”。

### ✅ 最小 DoD（建议 8-12 条）

#### 功能正确性
- [ ] 覆盖核心路径：正常流程可用
- [ ] 覆盖关键边界：错误输入/空数据/权限不足/网络失败等

#### 质量与可维护性
- [ ] 代码结构清晰：没有明显重复/硬编码/魔法常量
- [ ] 日志与错误处理到位：关键失败点可定位

#### 测试与验证
- [ ] 至少有一层验证：单测/集成测/手测清单（三选一必须有）
- [ ] 回归检查：没有破坏现有核心功能（列出检查点）

#### 风险控制
- [ ] 回滚方案明确：如何撤回（配置开关/回退提交/降级逻辑）
- [ ] 变更影响说明：影响哪些模块/用户/数据

#### 文档与交付
- [ ] PR/MR 描述写清楚：为什么改、怎么改、怎么验收
- [ ] 若有配置/环境变量变更：已记录并给出默认值/示例

**核心原则**:
- 先思考，后行动（消灭 50% 返工）
- 分工明确（每个阶段独立智能体）
- **持续验证（每个阶段都有产出）** ⭐⭐⭐

**效率提升**:
- 需求理解错误 → **减少 50% 返工**
- 架构设计问题 → **减少 70% 重构**
- 上线后 Bug → **降低 90% 风险**
- 整体开发周期 → **快 50%**

---

## 阶段0：写Spec（需求规格）⭐ 新增

> **先写Spec，不急着写代码** - 多AI协同的基础

### 目的
- 为AI提供清晰的任务描述
- 支持多AI并行开发
- 避免理解错误导致返工

### Spec模板（唯一真源）

```markdown
## Spec：[标题]

### 1) 目标（1句话）
- 我们要实现什么？（一句话，能被复述）

### 2) 背景/动机（可选）
- 为什么现在做？不做会怎样？

### 3) 用户场景（User Stories）
- 作为【用户角色】，我想要【能力】，以便【价值】

### 4) 范围（Scope）
- **做**：
  - …
- **不做**（防止范围膨胀）：
  - …

### 5) 成功指标 / 验收标准（可测试）
- 功能验收：
  - …
- 性能/稳定性：
  - …

### 6) 约束与假设（Constraints）
- 技术栈/平台约束：
- 兼容性：
- 数据/权限：

### 7) 边界情况（Edge Cases）
- 错误输入/异常流程：
- 降级/回滚策略：

### 8) 实施建议（给AI的提示）
- 需要修改哪些模块/文件大类？
- 推荐实现步骤（1-5步即可）

---

## ✅ Spec 完成标准（写完就能开工）
- 读完能清楚复述：**做什么、给谁用、做到什么算完成**
- 明确写了：**不做什么**
- 验收标准可测试，不是“体验更好”这种空话
```

### Spec示例

```markdown
## 用户评论功能

### 目标
让用户可以对文章进行评论和回复

### 用户场景
- 用户阅读文章后，可以发表评论
- 其他用户可以回复评论
- 作者可以收到通知

### 成功指标
- 评论加载时间 < 500ms
- 支持1000+评论不卡顿
- 实时通知延迟 < 3秒

### 技术要求
- 前端：React + TypeScript
- 后端：Node.js + Express
- 数据库：PostgreSQL
- 实时：WebSocket

### 边界情况
- 评论长度限制（1-500字）
- 敏感词过滤
- 评论删除/审核
- 匿名评论支持
```

### 多Spec并行处理

**场景**：同时开发3个功能

```bash
# 使用Schaltwerk等工具
Spec 1: 用户评论功能 → Agent 1
Spec 2: 数据导出功能 → Agent 2
Spec 3: 搜索优化 → Agent 3

# 3个AI同时工作
# 1小时后全部完成（传统需要3小时）
```

**相关文档**：
- [多AI协同开发](./03-多AI协同-Schaltwerk工具.md) - Schaltwerk完整教程
- [Vibe-Coding多AI协作](./01-思维方式-Vibe-Coding流水线思维.md) - 三线并进思维

---

## 阶段一：反向面试

### 目的
消灭 50% 返工，确保理解正确

### AI 提问内容
- **功能需求**: 核心目标、用户场景、成功指标
- **技术需求**: 性能要求、兼容性、安全要求
- **现有代码库**: 类似功能、架构规范、依赖服务
- **边界情况**: 错误处理、降级方案、MVP 范围

### 输出
- 需求文档
- 执行计划

---

## 阶段二：探索代码库

### 目的
了解现有资源，避免重复劳动

### 探索内容
- **架构**: 项目架构、技术栈、代码组织
- **相关功能**: 是否有类似功能、API 规范
- **依赖**: 主要依赖包、共享组件、基础设施配置
- **规范**: 代码风格、命名约定、测试要求

### 输出
- 代码库架构图
- 可复用资源清单
- 规范列表

---

## 阶段三：设计方案

### 目的
**不写代码，只设计方案**

### 设计内容
- **整体架构**: 新功能集成方式、模块依赖关系
- **数据结构**: 数据模型、数据库表结构、API 接口
- **技术选型**: 使用哪些库/框架、为什么选择
- **性能考虑**: 性能瓶颈、优化策略、预期指标
- **安全考虑**: 鉴权逻辑、数据保护、防攻击
- **错误处理**: 错误类型、处理策略、日志记录
- **测试策略**: 测试类型、覆盖范围

### 输出
- 架构设计文档
- API 接口文档
- 数据库设计
- 技术选型说明

---

## 阶段四：编码

### 目的
基于设计方案，实施高质量代码

### 实施步骤
1. **搭建基础结构**: 创建目录和文件、定义数据模型、配置路由
2. **实现核心功能**: 实现 API、业务逻辑、数据库操作
3. **集成现有系统**: 复用组件、遵循规范、保持风格
4. **添加错误处理**: 异常捕获、日志记录、降级方案

### 编码规范
- 遵循项目代码风格
- 添加必要的注释
- 保持函数简洁（<50 行）
- 单一职责原则

### 输出
- 实施后的代码
- 变更日志
- 已实现功能清单

---

## 阶段五：测试

### 目的
确保代码质量，发现潜在问题

### 测试内容
1. **单元测试**: 核心函数、测试覆盖率 > 80%、边界情况
2. **集成测试**: 与现有系统集成、API 接口、数据库操作
3. **性能测试**: 响应时间、并发、内存泄漏
4. **安全测试**: 输入验证、权限控制、SQL 注入/XSS

### 🚀 自动化加速：Ralph Wiggum 插件

**什么是 Ralph Wiggum？**
- 官方 Claude Code 插件，实现自动循环：测试 → 失败 → 分析 → 修复 → 再测试
- 基于停止钩子（Stop Hook）机制，让 Claude 自动迭代直到成功

**在测试阶段使用：**

```bash
# 场景1：自动修复测试失败
/ralph-loop "运行测试并修复所有失败的测试" --completion-promise "所有测试通过"

# 场景2：补充测试覆盖率
/ralph-loop "为 src/auth.ts 添加单元测试" --completion-promise "测试覆盖率 > 80%"

# 场景3：修复 linter 错误
/ralph-loop "修复所有 ESLint 错误" --completion-promise "0 linter 错误"
```

**优势：**
- ✅ 自动循环：无需手动复制错误信息重新提问
- ✅ 智能分析：Claude 理解错误日志并自动调整策略
- ✅ 可控制：设置最大迭代次数，避免无限循环
- ✅ 节省时间：从"手动测试→修改→再测试"变为"自动循环"

**注意事项：**
- ⚠️ 需要安装 Ralph Wiggum 插件：[详细文档](./06-工具-Ralph%20Wiggum自动迭代插件.md)
- ⚠️ 明确完成标准（`--completion-promise`），避免提前退出或无限循环
- ⚠️ 设置合理的最大迭代次数（`--max-iterations`），默认 50 次
- ⚠️ 适合 Bug 修复、补充测试，不适合需要人工决策的任务

### 输出
- 测试用例代码
- 测试覆盖率报告
- 性能测试结果
- 问题列表

---

## 阶段六：审查

### 目的
确保代码质量，无逻辑漏洞

### 审查内容
1. **逻辑审查**: 死循环、边界情况、错误处理、并发问题
2. **代码质量**: 复杂度、代码重复、命名、注释
3. **架构审查**: 设计文档符合性、架构模式、过度设计
4. **性能审查**: 性能瓶颈、不必要计算、查询优化
5. **安全审查**: 安全漏洞、敏感信息、权限控制、依赖漏洞

### 输出
- 审查报告
- 改进建议
- 优化计划

---

## 阶段七：发布

### 目的
正式发布，监控运行

### 发布内容
1. **发布前检查**: 测试通过、审查完成、文档更新、备份准备
2. **部署策略**: 蓝绿/金丝雀/滚动更新、回滚方案、监控告警
3. **灰度发布**: 10% → 50% → 100%，观察指标
4. **监控设置**: 告警（错误率 > 1%）、性能监控、日志聚合
5. **发布后验证**: 核心功能、性能指标、无新错误

### 输出
- 正式运行的代码
- 监控仪表盘
- 应急预案

---

## 📝 阶段产出模板

### 阶段一：需求文档模板

```markdown
# 需求文档：[功能名称]

## 1. 项目背景
- **业务场景**: [描述业务背景和问题]
- **现有问题**: [描述当前痛点]
- **解决目标**: [描述期望达到的目标]

## 2. 功能需求
### 2.1 核心功能
- 功能点1：[详细描述]
- 功能点2：[详细描述]
- 功能点3：[详细描述]

### 2.2 用户故事
- 作为[用户角色]，我想要[功能]，以便[价值]
- 作为[用户角色]，我想要[功能]，以便[价值]

### 2.3 成功指标
- [指标1]：[目标值]
- [指标2]：[目标值]

## 3. 非功能需求
### 3.1 性能要求
- 响应时间：< [X]ms
- 并发用户：> [X]人
- 数据处理：[X]条/秒

### 3.2 兼容性要求
- 浏览器：[列出支持浏览器]
- 设备：[PC/移动端/平板]
- 操作系统：[Windows/Mac/Linux]

### 3.3 安全要求
- [ ] 用户鉴权
- [ ] 数据加密
- [ ] 权限控制
- [ ] 审计日志

### 3.4 可用性要求
- 可用性：> [99.X]%
- 故障恢复：< [X]分钟
- 数据备份：[每日/实时]

## 4. 技术约束
- 技术栈：[列出技术栈]
- 依赖服务：[列出依赖]
- 第三方API：[列出API]

## 5. 边界情况
### 5.1 MVP范围
- [X] 功能1（必须）
- [X] 功能2（必须）
- [ ] 功能3（可选）

### 5.2 不包含
- [列出明确不包含的功能]

### 5.3 错误处理
- [列出预期的错误情况和处理方式]

## 6. 验收标准
- [ ] 所有核心功能正常工作
- [ ] 性能指标达标
- [ ] 测试覆盖率 > 80%
- [ ] 代码审查通过
- [ ] 文档完整

## 7. 时间计划
- 需求确认：[日期]
- 设计完成：[日期]
- 开发完成：[日期]
- 测试完成：[日期]
- 发布上线：[日期]
```

---

### 阶段三：设计文档模板

```markdown
# 设计文档：[功能名称]

## 1. 架构设计
### 1.1 整体架构
```
[插入架构图]

用户界面
    ↓
API层 (FastAPI/Express)
    ↓
业务逻辑层
    ↓
数据访问层
    ↓
数据库 (PostgreSQL/MongoDB)
```

### 1.2 模块划分
- **模块1**：[功能描述]
- **模块2**：[功能描述]
- **模块3**：[功能描述]

### 1.3 技术选型
| 技术 | 版本 | 用途 | 选择理由 |
|------|------|------|---------|
| [技术1] | [版本] | [用途] | [理由] |
| [技术2] | [版本] | [用途] | [理由] |

## 2. 数据库设计
### 2.1 数据模型
```sql
-- 表1：[表名]
CREATE TABLE [table_name] (
    id SERIAL PRIMARY KEY,
    field1 VARCHAR(255) NOT NULL,
    field2 INTEGER,
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW()
);

-- 索引
CREATE INDEX idx_field1 ON [table_name](field1);
```

### 2.2 ER图
```
[插入ER关系图]

User (1) ----< (N) Order
Order (1) ----< (N) OrderItem
Product (1) ----< (N) OrderItem
```

### 2.3 数据流
```
[描述数据如何在系统中流动]
```

## 3. API设计
### 3.1 REST API列表

#### 创建[资源]
```
POST /api/[resource]
Request Body:
{
    "field1": "value1",
    "field2": "value2"
}

Response (201):
{
    "id": 123,
    "field1": "value1",
    "field2": "value2",
    "created_at": "2025-12-25T10:00:00Z"
}

Error Response (400):
{
    "error": "Invalid input",
    "details": ["field1 is required"]
}
```

#### 获取[资源]列表
```
GET /api/[resource]?page=1&limit=20

Response (200):
{
    "data": [...],
    "total": 100,
    "page": 1,
    "limit": 20
}
```

#### 获取单个[资源]
```
GET /api/[resource]/:id

Response (200):
{
    "id": 123,
    "field1": "value1",
    ...
}
```

#### 更新[资源]
```
PUT /api/[resource]/:id

Request Body:
{
    "field1": "new_value1"
}

Response (200):
{
    "id": 123,
    "field1": "new_value1",
    "updated_at": "2025-12-25T11:00:00Z"
}
```

#### 删除[资源]
```
DELETE /api/[resource]/:id

Response (204): No Content
```

### 3.2 认证与鉴权
- 认证方式：[JWT/OAuth2/API Key]
- 权限模型：[RBAC/ABAC]
- 公开接口：[列出无需认证的接口]
- 受限接口：[列出需要权限的接口]

## 4. 业务逻辑设计
### 4.1 核心流程
```
[描述核心业务流程，可使用流程图]
```

### 4.2 状态机
```
[如果涉及状态变化，描述状态转换]
```

### 4.3 关键算法
```
[如果涉及复杂算法，描述算法逻辑]
```

## 5. 性能优化
### 5.1 性能目标
- API响应时间：p50 < [X]ms, p99 < [Y]ms
- 数据库查询：< [X]ms
- 缓存命中率：> [X]%

### 5.2 优化策略
- **缓存策略**：[Redis/Memcached，缓存什么数据]
- **数据库优化**：[索引、查询优化、分库分表]
- **CDN加速**：[静态资源使用CDN]
- **异步处理**：[消息队列、后台任务]

## 6. 安全设计
### 6.1 认证授权
- [描述认证流程]
- [描述授权机制]

### 6.2 数据保护
- **传输加密**：HTTPS/TLS
- **存储加密**：[敏感字段加密]
- **日志脱敏**：[日志中隐藏敏感信息]

### 6.3 防攻击措施
- **SQL注入**：参数化查询
- **XSS**：输入过滤、输出编码
- **CSRF**：CSRF Token
- **限流**：[每个IP每分钟X次请求]

## 7. 错误处理
### 7.1 错误码定义
| 错误码 | 含义 | HTTP状态码 | 处理方式 |
|-------|------|-----------|---------|
| E001 | 参数错误 | 400 | 返回具体错误信息 |
| E002 | 未授权 | 401 | 跳转登录 |
| E003 | 权限不足 | 403 | 返回权限不足提示 |
| E004 | 资源不存在 | 404 | 返回404页面 |
| E005 | 服务器错误 | 500 | 记录日志，返回通用错误 |

### 7.2 异常处理策略
- [可重试的异常处理方式]
- [不可重试的异常处理方式]
- [降级方案]

## 8. 测试策略
### 8.1 单元测试
- [需要测试的核心函数]
- [边界情况]
- [异常情况]

### 8.2 集成测试
- [API接口测试]
- [数据库集成测试]
- [第三方服务集成测试]

### 8.3 性能测试
- [压力测试场景]
- [并发测试]
- [长时间稳定性测试]

## 9. 部署方案
### 9.1 部署架构
```
[部署架构图]

负载均衡
    ↓
Web服务器 × 2
    ↓
应用服务器 × 3
    ↓
数据库 (主从)
```

### 9.2 部署步骤
1. [步骤1]
2. [步骤2]
3. [步骤3]

### 9.3 回滚方案
- [回滚触发条件]
- [回滚步骤]

## 10. 监控与告警
### 10.1 监控指标
- **业务指标**：[订单量、用户活跃度等]
- **技术指标**：[QPS、响应时间、错误率]
- **系统指标**：[CPU、内存、磁盘、网络]

### 10.2 告警规则
| 告警项 | 阈值 | 级别 | 通知方式 |
|-------|------|------|---------|
| 错误率 | > 1% | P1 | 短信+邮件 |
| 响应时间 | > 500ms | P2 | 邮件 |
| CPU使用率 | > 80% | P2 | 邮件 |

## 11. 验收标准
- [ ] 所有核心功能实现
- [ ] 所有API接口测试通过
- [ ] 测试覆盖率 > 80%
- [ ] 性能指标达标
- [ ] 安全审查通过
- [ ] 文档完整（设计文档、API文档、运维文档）

---

## 附录
### A. 参考文档
- [列出相关参考文档]

### B. 变更记录
| 日期 | 版本 | 变更内容 | 作者 |
|------|------|---------|------|
| [日期] | [版本] | [变更] | [作者] |
```

---

### 阶段五：测试报告模板

```markdown
# 测试报告：[功能名称]

## 测试概述
- **测试时间**：[开始日期] - [结束日期]
- **测试人员**：[姓名]
- **测试环境**：[环境描述]
- **测试工具**：[Jest/Pytest/Cypress等]

## 测试范围
### 功能测试
- [X] 核心功能1：[通过/失败]
- [X] 核心功能2：[通过/失败]
- [X] 核心功能3：[通过/失败]

### 性能测试
| 指标 | 目标值 | 实际值 | 状态 |
|------|-------|--------|------|
| API响应时间(p50) | < 100ms | [实际值] | [通过/失败] |
| API响应时间(p99) | < 500ms | [实际值] | [通过/失败] |
| 并发用户 | > 100 | [实际值] | [通过/失败] |

### 安全测试
- [X] SQL注入测试：[通过/失败]
- [X] XSS测试：[通过/失败]
- [X] 认证授权测试：[通过/失败]

## 测试结果
### 测试覆盖率
- **代码覆盖率**：[X]%
- **分支覆盖率**：[X]%
- **函数覆盖率**：[X]%

### 测试用例统计
| 类型 | 总数 | 通过 | 失败 | 通过率 |
|------|------|------|------|--------|
| 单元测试 | [X] | [X] | [X] | [X]% |
| 集成测试 | [X] | [X] | [X] | [X]% |
| 端到端测试 | [X] | [X] | [X] | [X]% |

### 发现的问题
| ID | 问题描述 | 严重程度 | 状态 | 负责人 |
|----|---------|---------|------|--------|
| BUG-001 | [描述] | [P1/P2/P3] | [待修复/已修复] | [姓名] |
| BUG-002 | [描述] | [P1/P2/P3] | [待修复/已修复] | [姓名] |

## 结论
### 测试结论
- [ ] 所有核心功能测试通过
- [ ] 测试覆盖率 > 80%
- [ ] 性能指标达标
- [ ] 所有关键Bug已修复

### 风险评估
- [列出已知的遗留问题]
- [评估风险等级]

### 发布建议
- [ ] 建议发布
- [ ] 建议延期，原因：[具体原因]

---

## 附录
### A. 测试数据
[详细测试数据]

### B. 性能测试报告
[性能测试详细报告]

### C. 截图/日志
[相关截图和日志]
```

---

### 阶段八：复盘（Retrospective）⭐ **新增**

> **"每一次开发都是学习的机会，复盘让经验固化为能力"**

### 为什么需要复盘？

**常见误区**：
- ❌ "AI开发不需要复盘，AI会自动学习" → AI只学当前项目，不会跨项目积累
- ❌ "复盘是团队的事，我一个人不需要" → 超级个体更需要复盘（没有同事可以问）
- ❌ "代码注释就是复盘" → 注释只记录"怎么做"，复盘记录"为什么"和"学到了什么"

**核心价值**：
- ✅ **避免重复踩坑**：下次遇到同样问题，5分钟解决（vs 第一次2小时）
- ✅ **加速技术决策**：查复盘文档，5分钟决定技术栈（vs 第一次纠结2天）
- ✅ **知识资产化**：形成个人知识库，未来可以写成书/课程/咨询

---

### 复盘的时机

**3个关键时机**：

1. **每个功能完成后**（推荐⭐⭐⭐⭐⭐）
   - 时间投入：15分钟
   - 趁热打铁，记忆清晰

2. **每个项目结束后**
   - 时间投入：2小时
   - 汇总所有功能的复盘，提炼共性模式

3. **遇到重大问题时**
   - 时间投入：30分钟
   - 专项复盘：问题分析、解决方案、预防措施

---

### 复盘的内容（5个维度）

#### 1. 技术决策（为什么）

```markdown
## 技术决策

### 选择A技术栈的原因
- 备选方案：React vs Vue vs Svelte
- 最终选择：React
- 原因：
  1. 生态更完善（需要的库都有）
  2. 未来招人更容易（React开发者多）
  3. 性能满足需求（不需要极致性能）

### 风险评估
- 风险：React学习曲线陡峭
- 缓解：先用AI辅助学习，1周上手
```

#### 2. 遇到的问题（踩坑记录）

```markdown
## 遇到的问题

### 问题1：状态管理混乱
- **现象**：组件间传 props 很痛苦
- **原因**：没有全局状态管理
- **尝试方案**：Context API（太复杂）→ Redux（太重）
- **最终方案**：Zustand（轻量+简单）
- **经验教训**：小项目也用状态管理，不要硬撑

### 问题2：API调用重复
- **现象**：每个组件都写一遍 fetch
- **解决方案**：封装 useRequest hook
- **效果**：代码量从200行减少到50行
```

#### 3. 成功经验（可复制）

```markdown
## 成功经验

### 经验1：AI辅助开发的最佳实践
- **做法**：先让AI写测试，再写实现
- **效果**：代码质量提升2倍
- **可复用场景**：所有新功能开发

### 经验2：Git分支策略
- **做法**：每个功能一个分支，完成后合并
- **好处**：可以随时切换功能，出问题快速回滚
```

#### 4. 数据和指标（量化）

```markdown
## 数据和指标

### 开发效率
- 预估时间：2天
- 实际时间：3天（+50%）
- 原因：低估了状态管理的复杂度

### AI使用情况
- AI生成代码占比：70%
- 手写代码占比：30%
- AI重写次数：3次（第一次生成的不能用）

### 质量指标
- Bug数：2个
- 测试覆盖率：85%
- 性能：首屏加载<2秒 ✅
```

#### 5. 改进建议（下次怎么做）

```markdown
## 改进建议

### 技术层面
1. **下次项目**：一开始就用状态管理（不要硬撑）
2. **下次项目**：先用AI写测试，再写实现
3. **下次项目**：预估时间×1.5（预留buffer）

### 流程层面
1. **优化**：阶段5（测试）增加自动化测试
2. **优化**：阶段3（设计）增加技术选型评估
3. **新增**：阶段8（复盘）← 就在现在！

### 工具层面
1. **新增**：配置ESLint+Prettier（统一代码风格）
2. **新增**：配置Husky（提交前自动测试）
```

---

### 复盘的存储方式

**推荐**：项目内复盘文档

```bash
项目根目录/
└── docs/
    └── retrospective/
        ├── 2024-01-05-用户评论功能.md
        ├── 2024-01-10-数据导出功能.md
        ├── 2024-01-15-搜索优化.md
        └── 2024-01-30-项目总结.md
```

**优点**：
- ✅ 与项目代码一起，版本管理
- ✅ 方便回顾：直接在项目中查看历史
- ✅ 易于维护：每个功能一个文件

**复盘文档模板**：

```markdown
# [功能名称]复盘

> **开发时间**：2024-01-05 | **开发者**：AI+我 | **用时**：3天

---

## 技术决策
（见上文5个维度）

## 遇到的问题
（见上文5个维度）

## 成功经验
（见上文5个维度）

## 数据和指标
（见上文5个维度）

## 改进建议
（见上文5个维度）

---

## 附录

### 相关链接
- 需求文档：[链接]
- 设计文档：[链接]
- 代码提交：[commit hash]
```

---

### 15分钟复盘法

**时间分配**：
```
5分钟：填写技术决策（凭记忆）
5分钟：记录遇到的问题（看git log）
5分钟：写下改进建议（最重要）
```

**核心原则**：
- ✅ 不要追求完美
- ✅ 先记录，再优化
- ✅ 哪怕只有3条，也比没有强

---

### AI辅助复盘

**如何让AI帮你复盘？**

```bash
# 提示词模板
请帮我复盘这个功能的开发过程：

**功能名称**：[功能名]
**开发时间**：[开始] - [结束]
**Git提交记录**：[粘贴主要commit]

请分析：
1. 哪些技术决策是正确的？
2. 遇到了哪些问题？如何解决的？
3. 哪些做法值得下次复制？
4. 下次如何改进？

要求：
- 诚实客观（不要只说好话）
- 具体可行（不要空泛）
- 量化数据（用数字说话）
```

---

### 复盘的价值量化

**投入**：
- 每个功能复盘：15分钟
- 10个功能：2.5小时
- 1年（100个功能）：25小时

**收益**：
- 避免重复踩坑：每个坑节省2小时 × 10个坑 = 20小时
- 加速技术决策：每次决策节省1小时 × 20次 = 20小时
- 代码复用：成功经验节省10小时 × 5次 = 50小时
- **总收益**：90小时/年

**ROI**：90小时收益 / 25小时投入 = **3.6倍**

---

### 最佳实践

1. **定期回顾复盘**
   - 月度回顾：提炼最值得复制的3个经验
   - 季度回顾：更新个人技术栈选择指南

2. **形成知识库**
   - 跨项目查看，寻找共性模式
   - 未来可以写成技术博客/书/课程

3. **复盘是超级个体的核心竞争力**
   - 团队有同事可以问，你只有复盘文档
   - 记录下来，未来的你会感谢现在的你

---

## 🎯 一键执行完整流程（8阶段完整版）

```
"执行完整的开发项目：

【阶段一：反向面试】
向我提问并确认需求，生成需求文档

【阶段二：探索代码库】
探索现有代码库（架构、规范、可复用代码），生成资源清单

【阶段三：设计方案】
设计技术方案（不执行），生成架构文档

【阶段四：实施开发】
基于设计方案，编写代码，生成实施日志

【阶段五：测试】
编写测试用例并执行，生成测试报告

【阶段六：审查】
审查代码质量和逻辑，生成审查报告

【阶段七：发布】
正式发布，开始监控运行

【阶段八：复盘】⭐ 新增
记录开发过程中的技术决策、遇到的问题、成功经验和改进建议，生成复盘文档

每个阶段完成后，向我汇报并等待确认再进入下一阶段。

现在开始阶段一：反向面试"
```

---

## 📊 效率对比

| 方式 | 传统开发 | feature-dev | 提升 |
|------|---------|------------|----|
| **需求理解** | 边做边改 | 反向面试确认 | **减少 50% 返工** |
| **架构设计** | 直接实施 | 先设计后实施 | **减少 70% 重构** |
| **问题发现** | 上线后发现 | 早期测试发现 | **降低 90% 风险** |
| **代码质量** | 人工审查 | 自动化审查 | **提升 80% 质量** |
| **整体周期** | 4-6 周 | 2-3 周 | **快 50%** |

---

## ⚠️ 关键原则

### 1. 谋定而后动
- ✅ 先设计方案，再实施
- ✅ 先测试，再发布
- ❌ 不直接开始执行

### 2. 分阶段验证
- ✅ 每个阶段都有产出
- ✅ 每个阶段都等待确认
- ❌ 不一口气做完

### 3. 持续沟通
- ✅ 每个阶段后汇报
- ✅ 发现问题立即讨论
- ❌ 不等到最后才展示

### 4. 质量优先
- ✅ 测试覆盖率 > 80%
- ✅ 代码审查必须通过
- ✅ 性能指标达标
- ❌ 不牺牲质量

---

## 💡 适用场景

### ✅ 推荐使用 feature-dev

- 涉及 **5+ 文件修改**的任务
- 需要**严格架构规范**的功能
- **复杂业务逻辑**实现
- 需要**代码审查**的项目
- **多文件重构**任务
- **性能优化**项目
- **架构迁移**项目

### ❌ 不推荐使用 feature-dev

- 单个文件修改
- 简单 Bug 修复
- 快速查询
- 临时调试
- 文档更新

---

## 🔧 安装指南

### 在 VSCode 中使用（推荐）

如果你正在使用 VSCode 扩展版的 Claude Code：

1. **打开命令面板**
   - 按 `Ctrl+Shift+P` (Windows/Linux)
   - 或 `Cmd+Shift+P` (Mac)

2. **输入并执行以下命令**
   ```
   /plugin marketplace add anthropics/claude-code
   /plugin install feature-dev
   ```

3. **验证安装**
   ```
   /plugin list
   ```
   应该看到 `feature-dev` 已安装

4. **开始使用**
   ```
   使用 feature-dev 智能体工作流，帮我 [描述你的任务]
   ```

### 在终端中使用

如果你使用终端版 Claude Code：

1. **启动 Claude Code 交互式会话**
   ```bash
   claude
   ```

2. **在会话中执行安装命令**
   ```
   /plugin marketplace add anthropics/claude-code
   /plugin install feature-dev
   ```

3. **验证安装**
   ```
   /plugin list
   ```

4. **开始使用**
   ```
   使用 feature-dev，帮我 [描述你的任务]
   ```

---

## 💡 实战案例

### 案例 1：开发用户认证系统

```
使用 feature-dev，帮我实现用户认证系统

要求：
1. 支持邮箱/密码登录
2. JWT Token 鉴权
3. 密码加密存储（bcrypt）
4. 登录失败处理（防暴力破解）
5. 单元测试覆盖率 > 80%
6. 支持找回密码功能
```

**执行流程**：
- 阶段一：确认认证方式、密码策略、Token过期时间
- 阶段二：探索现有代码库（数据库结构、路由配置）
- 阶段三：设计API接口（/login、/register、/forgot-password）
- 阶段四：实现功能（bcrypt加密、JWT生成、中间件）
- 阶段五：编写测试（登录成功/失败、Token验证）
- 阶段六：代码审查（安全性、性能、错误处理）
- 阶段七：灰度发布（10% → 100%）

**结果**：2周完成，测试覆盖率85%，无安全漏洞

---

### 案例 2：API 性能优化

```
使用 feature-dev，帮我优化 API 性能

目标：
- API 响应时间 < 200ms（当前平均 800ms）
- 数据库查询优化
- 引入缓存策略（Redis）
- 前端加载优化（CDN）
```

**执行流程**：
- 阶段一：确认性能指标、瓶颈分析方向
- 阶段二：探索现有代码（API端点、数据库查询、缓存现状）
- 阶段三：设计优化方案（数据库索引、Redis缓存、CDN配置）
- 阶段四：实施优化（添加索引、实现缓存、配置CDN）
- 阶段五：性能测试（压力测试、对比优化前后）
- 阶段六：审查（优化效果、是否有副作用）
- 阶段七：发布（监控性能指标）

**结果**：API响应时间降至150ms，提升81%

---

### 案例 3：Repository 重构

```
使用 feature-dev，帮我重构数据访问层

目标：
- 引入 Repository 模式
- 支持多种数据库（PostgreSQL、MySQL）
- 改进错误处理
- 保持向后兼容
```

**执行流程**：
- 阶段一：确认重构范围、数据库支持清单
- 阶段二：探索现有代码（数据访问层、数据库配置）
- 阶段三：设计Repository接口（BaseRepository、CRUD操作）
- 阶段四：实施重构（实现Repository、迁移现有代码）
- 阶段五：编写测试（单元测试、集成测试）
- 阶段六：代码审查（设计模式、兼容性）
- 阶段七：发布（灰度迁移、回滚方案）

**结果**：支持3种数据库，代码量减少30%

---

## 🔗 相关文档

- [应用产品开发需求发现指南](../01-产品设计/应用产品开发需求发现指南.md) - 竞品分析与用户洞察（前置要求）
- [README.md](./README.md) - 快速导航

---

## 📋 版本记录

### v2.0 (2025-12-25)
- [OK] 新增：安装指南（VSCode + 终端）
- [OK] 新增：3个实战案例（用户认证、性能优化、Repository重构）
- [OK] 整合：删除独立的安装指南和案例文档
- [OK] 优化：文档结构更清晰

### v1.0 (2025-12-24)
- [OK] 初始版本
- [OK] 8阶段智能体工作流（含复盘）

---

**创建时间**: 2025-12-25
**当前版本**: v2.0
**理念来源**: feature-dev 插件

**谋定而后动，快就是慢！** 🚀

